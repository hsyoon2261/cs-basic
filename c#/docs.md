```cs
using System;

class Hello
{
    static void Main()
    {
        Console.WriteLine("Hello, World");
    }
}
```

“Hello, World” 프로그램은 <u>**_System 네임스페이스를 참조하는 using 지시문으로 시작합니다.**</u> 네임스페이스는 계층적으로 C# 프로그램 및 라이브러리를 구성하는 방법을 제공합니다. 네임스페이스에는 형식 및 다른 네임스페이스가 포함됩니다. 예를 들어 System 네임스페이스에는 많은 형식(예: 프로그램에 참조되는 Console 클래스) 및 많은 다른 네임스페이스(예: IO 및 Collections)가 포함되어 있습니다. 지정된 네임스페이스를 참조하는 using 지시문을 사용하여 해당 네임스페이스의 멤버인 형식을 정규화되지 않은 방식으로 사용할 수 있습니다. using 지시문 때문에, 프로그램은 Console.WriteLine을 System.Console.WriteLine의 약식으로 사용할 수 있습니다.

“Hello, World” 프로그램에서 선언된 Hello 클래스에는 단일 멤버인 Main 메서드가 있습니다. 

`Main` 메서드는 static 한정자로 선언됩니다.

  인스턴스 메서드는 키워드 this를 사용하여 특정 바깥쪽 개체 인스턴스를 참조할 수 있지만 정적 메서드는 특정 개체에 대한 참조 없이 작동합니다. 관례상 Main이라는 정적 메서드가 C# 프로그램의 진입점으로 사용됩니다.

프로그램의 출력은 System 네임스페이스에 있는 Console 클래스의 WriteLine 메서드에 의해 생성됩니다. 이 클래스는 기본적으로는 컴파일러에서 자동으로 참조되는 표준 클래스 라이브러리를 통해 제공됩니다.

  `class` 형식은 데이터 멤버(필드) 및 함수 멤버(메서드, 속성 및 기타)를 포함하는 데이터 구조를 정의합니다. 클래스 형식은 단일 상속 및 다형성과 파생된 클래스가 기본 클래스를 확장하고 특수화할 수 있는 메커니즘을 지원합니다.

``struct`` 형식은 데이터 멤버 및 함수 멤버로 구조체를 나타내는 클래스 형식과 유사합니다. 그러나 클래스와 달리 구조체는 값 형식이며 일반적으로 힙 할당이 필요하지 않습니다. 구조체 형식은 사용자 지정 상속을 지원하지 않으며 모든 구조체 형식은 object 형식으로부터 암시적으로 상속됩니다.

`interface` 형식은 계약을 공용 멤버의 명명된 집합으로 정의합니다. interface를 구현하는 class 또는 struct는 인터페이스의 멤버 구현을 제공해야 합니다. interface는 여러 기본 인터페이스에서 상속될 수 있으며 class 또는 struct는 여러 인터페이스를 구현할 수 있습니다.

`delegate` 형식은 특정 매개 변수 목록 및 반환 형식이 있는 메서드에 대한 참조를 나타내는 형식입니다. 대리자는 메서드를 변수에 할당되고 매개 변수로 전달될 수 있는 엔터티로 취급할 수 있도록 합니다. 대리자는 함수 언어에서 제공하는 함수 형식과 유사합니다. 대리자는 다른 언어의 함수 포인터와 개념이 비슷하지만 함수 포인터와 달리 대리자는 개체 지향적이며 형식이 안전한 방식입니다.

class, struct, interface 및 delegate 형식은 모두 `제네릭`을 지원하므로 다른 형식으로 매개 변수화할 수 있습니다.

`C#은 모든 형식의 1차원 및 다차원 배열을 지원합니다. 위에 나열된 형식과 달리, 배열 형식은 사용하기 전에 먼저 선언할 필요가 없습니다. 대신, 배열 형식은 형식 이름을 대괄호로 묶어 생성합니다. 예를 들어 int[]는int의 1차원 배열이고, int[,]는 int의 2차원 배열, int[][]는 int의 1차원 배열의 1차원 배열, 즉 "가변" 배열입니다.`

`nullable` 형식에는 별도의 정의가 필요하지 않습니다. null을 허용하지 않는 형식 T의 경우, 대응되는 nullable 형식 T?가 있으며 이는 추가 값 null을 가질 수 있습니다. 예를 들어 int?는 32비트 정수 또는 null 값을 보유할 수 있는 형식이고, string?은 모든 string 또는 null 값을 보유할 수 있는 형식입니다.

C#의 형식 시스템은 모든 형식의 값이 object로 취급될 수 있도록 통합됩니다. 

C#의 모든 형식은 object 클래스 형식에서 직접 또는 간접적으로 파생되고 object는 모든 형식의 기본 클래스입니다. 

참조 형식의 값은 object로 인식함으로써 간단히 개체로 처리됩니다. 

값 형식의 값은 boxing 및 unboxing 작업 을 수행하여 개체로 처리됩니다. 

다음 예제에서 int 값은 object로 변환되었다가 다시 int로 변환됩니다.

```cs
int i = 123;
object o = i;    // Boxing (making object)
int j = (int)o;  // Unboxing (using object element by int)
```

C#의 핵심 조직 개념은 ‘프로그램’, ‘네임스페이스’, ‘형식’, ‘멤버’, ‘어셈블리’입니다.*_ 프로그램은 멤버를 포함하고 네임스페이스로 구성될 수 있는 형식을 선언합니다. 클래스, 구조체 및 인터페이스는 형식의 예입니다. 필드, 메서드, 속성 및 이벤트는 멤버의 예입니다. C# 프로그램을 컴파일하면 실제로 어셈블리로 패키지됩니다. 어셈블리는 일반적으로 애플리케이션을 구현하는지 또는 *라이브러리**를 구현하는지에 따라 각각 파일 확장명 .exe 또는 .dll을 갖습니다.

```cs
namespace Acme.Collections;

public class Stack<T> //제너릭 클래스 , 구체적인 형식으로 대체되는 T 형식 매개변수 하나 포함
{
    Entry _top;

    //아래 줄로 push pop => FILO(LIFO) 선입후출 스택클래스 =? next, data를 알아야함. 
    public void Push(T data)
    {
        _top = new Entry(_top, data);
    }

    public T Pop()
    {
        if (_top == null)
        {
            throw new InvalidOperationException();
        }
        T result = _top.Data;
        _top = _top.Next;

        return result;
    }

    class Entry
    {
        public Entry Next { get; set; }  //생성자
        public T Data { get; set; } // 생성자

        public Entry(Entry next, T data)
        {
            Next = next; //속성1
            Data = data; //속성2
        }
    }
}
```

# Class

개체 지향 언어인 C#은 캡슐화, 상속 및 다형성의 개념을 지원합니다. 

클래스는 단일 부모 클래스에서 직접 상속될 수 있으며 원하는 수의 인터페이스를 구현할 수 있습니다. 

부모 클래스에서 가상 메서드를 재정의하는 메서드에는 우발적인 재정의를 방지하는 방법으로 override 키워드가 필요합니다. 

C#에서 구조체는 간단한 클래스와 같습니다. 
즉, 인터페이스를 구현할 수 있지만 `상속을 지원하지 않는 스택 할당 형식입니다.` C#은 또한 주로 데이터 값을 저장하는 용도로 사용할 수 있는 형식인 record class 및 record struct 형식을 제공합니다.

클래스 는 C#의 가장 기본적인 형식입니다. `클래스는 상태(필드)와 작업(메서드 및 기타 함수 멤버)을 하나의 단위로 결합하는 데이터 구조입니다.` 

클래스는 해당 클래스의 `‘인스턴스’(‘개체’라고도 함)에 대한 정의를 제공합니다.` 클래스는 `상속` 및 `다형성` 과 `파생된 클래스` 가 기본 클래스 를 확장하고 특수화할 수 있는 메커니즘을 지원합니다.

새 클래스는 클래스 선언을 사용하여 만들어집니다. 클래스 선언은 헤더로 시작합니다. 헤더는 다음을 지정합니다.

`헤더`
 - 클래스의 특성 및 한정자
- 클래스의 이름
- 기본 클래스(기본 클래스에서 상속하는 경우)
- 이 클래스에서 구현한 인터페이스

헤더 다음에는 구분 기호 { 및 } 간에 작성되는 멤버 선언 목록으로 구성되는 클래스 본문이 나옵니다.

다음 코드는 Point라는 간단한 클래스의 선언입니다.


```cs  
Point.cs

public class Point
{
    public int X { get; }
    public int Y { get; }
    
    public Point(int x, int y) => (X, Y) = (x, y);
}

```

클래스의 인스턴스는 새 인스턴스에 대한 메모리를 할당하고, 인스턴스를 초기화하는 생성자를 호출하고, 인스턴스에 대한 참조를 반환하는 `new` 연산자를 사용하여 만들어집니다. 다음 문은 두 개의 `Point` 개체를 만들고 해당 개체에 대한 참조를 두 변수에 저장합니다.

```cs
var p1 = new Point(0, 0);
var p2 = new Point(10, 20);
```

개체가 차지하는 메모리는 개체에 더 이상 연결할 수 없을 때 자동으로 회수됩니다. **C#에서는 개체를 명시적으로 할당 취소할 필요가 없으며 가능하지도 않습니다.**


## 기본 클래스

다음 예제에서 Point3D의 기본 클래스는 Point입니다. 첫 번째 예제에서 Point의 기본 클래스는 object입니다.

```cs
public class Point3D : Point
{
    public int Z { get; set; }
    
    public Point3D(int x, int y, int z) : base(x, y)
    {
        Z = z;
    }
}
```

`클래스는 기본 클래스의 멤버를 상속합니다. `

 상속은 클래스가 기본 클래스의 거의 모든 멤버를 암시적으로 포함함을 의미합니다. 
 
 클래스는 인스턴스 및 정적 생성자와 종결자는 상속하지 않습니다. 
 
 파생 클래스는 해당 파생된 클래스를 상속하는 멤버에 새 멤버를 추가할 수 있지만 상속된 멤버의 정의를 제거할 수 없습니다. 
 
 앞의 예제에서 Point3D는 Point에서 X 및 Y 멤버를 상속하고 모든 Point3D 인스턴스는 세 개의 속성, 즉 X, Y 및 Z를 포함합니다.

 클래스 형식에서 해당 기본 클래스 형식 간에 암시적 변환이 존재합니다. 클래스 형식의 변수는 해당 클래스의 인스턴스 또는 모든 파생 클래스의 인스턴스를 참조할 수 있습니다. 예를 들어 이전 클래스 선언에서 형식 Point의 변수는 Point 또는 Point3D를 참조할 수 있습니다.

 ```cs
Point a = new(10, 20);
Point b = new Point3D(10, 20, 30);
```

## 제네릭 클래스

`제네릭 클래스는 형식 매개 변수를 정의합니다.` 형식 매개 변수는 대괄호로 묶인 형식 매개 변수 이름 목록입니다. 형식 매개 변수는 클래스 이름을 따릅니다. 그런 후 `형식 매개 변수를 클래스 선언 본문에 사용하여 클래스의 멤버를 정의할 수 있습니다.`

```cs
public class Pair<TFirst, TSecond>
{
    public TFirst First { get; }
    public TSecond Second { get; }
    
    public Pair(TFirst first, TSecond second) => 
        (First, Second) = (first, second);
}
```

형식 매개 변수를 사용하도록 선언된 클래스 형식을 제네릭 클래스 형식 이라고 합니다. 구조체, 인터페이스 및 대리자 형식도 제네릭일 수 있습니다. 제네릭 클래스를 사용하는 경우 각 형식 매개 변수에 대해 다음과 같은 형식 인수가 제공되어야 합니다.

```cs
var pair_ex = new Pair<int, string>(1, "two");
int i = pair_ex.First;     //TFirst int
string s = pair_ex.Second; //TSecond string
```

위의 Pair<int,string>과 같이 형식 인수가 제공된 제네릭 형식을 생성된 형식 이라고 합니다.

